# Отладка модулей и приложений

#### Что обсуждается в этой главе?

* Форматирование и вывод переменных
* Использование интерполяции переменных
* Использование отладчика Node
* Использование визуального отладчика Node

---

Построение функционального программного обеспечения — не тривиальная задача. Разделение кода приложения на маленькие модули и доскональное тестирование каждого модуля может помочь, но вы все еще обязаны находить проблемы. Если вам понадобится проинспектировать внутренние механизмы вашего приложения или модуля Node, в этом могут помочь несколько приложений. Данная глава покрывает несколько таких средств отладки — `console.log`, встроенный отладчик Node и инспектор Node.

## Использование console.log

В Node доступно несколько глобальных объектов, которые вы можете использовать без явного импортирования. Один из них — это объект `console`, который позволяет выводить форматированные строки.

Простейшее средство отладки в вашем распоряжении — это `console.log`. Вызов данной функции делает две вещи: сериализует и конкатенирует переданные объекты в строку и выводит результат в стандартный поток вывода. Вы можете использовать его для инспектирования объектов:

    var obj = {a: 1, b: 2};
    console.log(obj);

Этот код выводит следующее:

    { a: 1, b: 2 }

Этот простой пример передает объект, который транслируется в литеральное строковое представление. Вы можете передать объект любого типа, и `console.log` проинспектирует все его свойства и значения.

#### Примечание:

На самом деле, `console.log` *не* выполняет никакого форматирования. Все форматирование выполняется функцией `util.format`. Какие бы аргументы вы не передавали в `console.log`, они перенаправляются функции `util.format`, а результат отправляется в стандартный поток вывода. Это значит, что любые из этих вызовов `console.log` могут непосредственно применяться к util.format.

---

Функция `console.log` инспектирует только собственные перечисляемые свойства, а значит, свойства цепочки прототипов и неперечисляемые свойства не будут отображены. Например, этот код отображает экземпляр класса EventEmitter в Node консоли:

    > var EventEmitter = require('events').EventEmitter;
    undefined
    > var emitter = new EventEmitter();
    undefined
    > console.log(emitter);
    {}
    undefined
    > emitter.on('data', function() { });
    { _events: { data: [Function] } }
    > console.log(emitter);
    { _events: { data: [Function] } }
    undefined

Из этого примера видно, что когда вы в первый раз передаете функции `console.log` значение `emitter`, она печатает пустой объект. Это происходит, потому что объект `emitter` не имеет свойства, установленных во время конструирования. Затем, после привязки слушателя события, объект получает свойство с именем _events, которое печатается при следующем вызове `console.log`.

Функция `console.log` также может выводить массивы:

    > var arr = [1, 2, 3];
    undefined
    > console.log(arr);
    [ 1, 2, 3 ]
    undefined

Функция `console.log` также предоставляет — через функцию `util.format` — возможность интерполировать значения в строки, с помощью указания специальных символов, начинающихся с % внутри строки:

    > console.log('an object: %j and a number: %d', {a:1, b:2}, 0xfa);
    an object: {"a":1,"b":2} and a number: 250
    undefined

%j используется для JSON-формата объекта, %d — для вывода числа (целого или вещественного), а %s — для вывода строки.

Если вы передадите `console.log` дополнительные аргументы, которые не имеют интерполяционных символов в шаблонной строке, или просто передадите аргументы без шаблонной строки, `console.log` просто отформатирует и конкатенирует их, разделяя символами пробела.

    > console.log({a:1, b:2}, 0xfa);
    { a: 1, b: 2 } 250
    undefined
    > console.log('an object: %j and a number:', {a:1, b:2}, 0xfa);
    an object: {"a":1,"b":2} and a number: 250
    undefined

#### Примечание

Функция `console.log` просто выводит результирующую строку, получаемую из функции util.format, добавляет символ новой строки, и отправляет ее в стандартный поток вывода. Однако, запись в поток вывода в Node является блокирующей операцией, а значит, цикл событий будет заблокирован до тех пор, пока совершается логирование. В зависимости от приложения и частоты использования данной функции, может уменьшиться скорость отклика приложения, а значит, необходимо избегать использования функции `console.log` в рабочем коде.

## Использование встроенного отладчика Node

Использование `console.log` для инспектирования переменных может быстро стать неуправляемым, особенно когда проблема, которую вы пытаетесь исправить, нетривиальна. Когда расположение проблемы трудно найти, может появиться желание добавить множество инструкций логирования, делая при этом вывод программы слишком многословным. Хуже всего, если вы будtете запускть программу и воспроизводить проблему каждый раз при добавлении новых инструкций логов.

К счастью, виртуальная JavaScript-машина V8 предоставляет интерфейс отладки, который также поддерживается и в Node. Если вам нужна точка останова для тщательного инспектирования приложения, вы можете использовать встроенный отладчик Node. Несмотря на то, что он прост и универсален, его может быть достаточно для отладки приложений без установки других инструментов.

Для начала, создайте простое приложение и внесите в него ошибку, с которой можно будет поэксперементировать в отладчике:

    var a = 0;
    
    function init() {
        a = 1;
    }
    
    function incr() {
        var a = a + 1;
    }
    
    init();
    console.log('a before: %d', a);
    
    incr();
    console.log('a after: %d', a);

Если запустить данное приложение, можно увидеть следующий вывод:

    a before: 1
    a after: 1

Вы можете видеть, что переменная `a` не увеличилась, как вы того хотели. Следующий шаг - запуск Node в режиме отладки:

    $ node debug my_app.js

Этот отрывок кода запускает Node в режиме отладки и запускает отладчик. Это запустит приложение, но остановит выполнение на первой строке главного модуля. При этом вы получаете строку ввода отладчика и позицию текущей инструкции.

    < debugger listening on port 5858
    connecting... ok
    break in my_app.js:1
        1 var a = 0;
        2
        3 function init() {

Вы можете использовать строку ввода для отображения всех команд:

    debug> help
    Commands: run (r), cont (c), next (n), step (s), out (o), backtrace (bt),
    setBreakpoint (sb), clearBreakpoint (cb), watch, unwatch, watchers,
    repl, restart, kill, list, scripts, breakpoints, version

Теперь вы можете продолжить выполнение к следующей инструкции:

    debug> next

Это продолжит выполнение и остановит его на следующей инструкции в той же области видимости:

    break in my_app.js:11
    9 }
    10
    11 init();
    12 console.log('a before: %d', a);
    13

Затем, вместо использования команды продолжения в текущей области `next`, вы входите в вызов функции init():

    debug> step
    break in my_app.js:4
        2
        3 function init() {
        4 a = 1;
        5 }
        6

Теперь вы можете посмотреть состояние стека вызовов:

    debug> backtrace
    #0 my_app.js:4:3
    #1 my_app.js:11:1

Также можно установить наблюдение за переменной `watch`:

    debug> watch('a')

Эта команда добавляет `a` в список наблюдения, который вы можете просмотреть:

    debug> watchers
        0: a = 0

Здесь вы можете видеть, что переменная `a` имеет значение 0 в локальной области видимости.

Теперь вы можете перейти на следующую команду:

    debug> next
    break in my_app.js:5
    Watchers:
        0: a = 1
        3 function init() {
        4 a = 1;
        5 }
        6
        7 function incr() {

Эта инструкция отладчика запускает следующую комаду и отображает список наблюдения и следующую строку выполнения. Вы можете видеть, что переменная `a` теперь имеет значение 1.

Теперь вы находитесь в конце функции init, готовой к возврату. Вы можете использовать команду `out`, чтобы пропустить выполнение до следующей инструкции в родительской области видимости или использовать команду next:

    debug> next
    break in my_app.js:12
    Watchers:
        0: a = 1
        
        10
        11 init();
        12 console.log('a before: %d', a);
        13
        14 incr();

Что, если вы хотите пропустить строку 12 и перепрыгнуть на выполнение вызова функции incr? Чтобы сделать это, нужно установить контрольную точку на строку 8 файла my_app.js:

    debug> sb ('my_app.js', 8)
        7 function incr() {
        * 8 var a = a + 1;
        9 }
        10
        11 init();
        12 console.log('a before: %d', a);
        13
        14 incr();
        15 console.log('a after: %d', a);
        16 });

У вас есть контрольная точка на строке 8, а текущая инструкция — на линии 12. Теперь можно перенаправить выполнение в контрольную точку:

    debug> cont
    < a before: 1
    break in my_app.js:8
    Watchers:
        0: a = undefined
        6
        7 function incr() {
      * 8 var a = a + 1;
        9 }
        10

С помощью изучения вывода отладчика вы можете определить проблему в приложении. Отладчик сообщает, что предыдущее значение переменной `a` было 1, а новое значение - `undefined`. Это происходит из-за использования ключевого слова var в строке 8, которое создает локальную переменную вместо использования глобальной. Теперь, когда вы знаете что вы сделали не так, вы можете выйти из отладчика с помощью нажатия Ctrl-D и исправить проблему путем удаления ключевого слова var из строки 8.

    var a = 0;
    
    function init() {
        a = 1;
    }
    
    function incr() {
        a = a + 1;
    }
    
    init();
    console.log('a before: %d', a);
    
    incr();
    console.log('a after: %d', a);

Запустите приложение снова:

    $ node my_app.js
    a before: 1
    a after: 2

Теперь вывод соответствует ожиданиям; проблема устранена.

## Использование отладчика Node

Другой инструмент отладки, который вы можете найти полезным — это Инспектор Node. Вместо использования исключительно текстового отладчика, инспектор предоставляет графический интерфейс, интегрируя полноценный инспектор Google Chrome с Node-приложением с помощью браузера.

Вы можете установить Node Inspector глобально:

    $npm install -g node-inspector

По умолчанию Node Inspector запускается как демон на порте 8080. Запустить его можно следующим образом:

    $ node-inspector &

Это запускает node-inspector в фоновом режиме.

Далее нужно запустить приложение, используя опции --debug или --debug-brk:

    $ node --debug-brk my_app.js

Опция `--debug-brk` заставляет приложение прерываться на первой строке, в то время как опция `debug` просто разрешает отладку.

#### Примечание:

При отладке серверов используйте --debug, при отладке других скриптов может появиться необходимость прервать выполнение на первой строке с помощью --debug-brk.

---

Теперь вы можете открыть свой браузер и перейти на http://localhost:8080, после чего вы должны получить нечто подобное:

screenshot 174

Вы можете устанавливать и удалять контрольные точки, кликая на номерах строк.

Когда контрольная точка достигнута, приложение останавливается и Node Inspector показывает контекст.

screenshot 174

Справа также расположены две контекстные панели:

* Стек вызовов, где вы можете видеть какие функции были вызваны.
* Переменные области видимости, где вы можете просмотреть локальные переменные, глобальные переменные, и переменные замыканий.

Выше этих панелей расположены несколько кнопок, которые можно использовать для манипуляции выполняемыми инструкциями.

screenshot 175

#### Примечание:

Live Edit describes the process whereby you change code while you are debugging. You simply double-click on a line of code and edit it. Change the code and press the Tab key or click outside the edit area. You just changed the running code!

However, note that changing the code using Live Edit will not save the changes — use it only to test quick fi xes.

---

## Резюме

Вы можете использовать `console.log` для вывода некоторого состояния приложения, что поможет вам отладить его. Используя данную функцию, вы можете форматировать и выводить переменные, чтобы отобразить состояние приложения.

Если вы столкнулись с более сложной проблемой, вы можете использовать встроенный консольный отладчик Node. Кроме того, вы можете использовать Node Inspector, который является графической альтернативой и использует браузер и некоторые более сложные опции. Node Inspector также позволяет редактировать код непосредственно в процессе отладки.