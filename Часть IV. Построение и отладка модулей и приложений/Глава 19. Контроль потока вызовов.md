# Контроль потока вызовов

#### Что обсуждается в этой главе?

* Что такое эффект бумеранга
* Избегание глубого вложенных функций
* Построение программы контроля асинхронного потока
* Использование `async` для контроля потока вызовов
* Использование `async` для асинхронных итераций

---

Когда Node выполняет асинхронные операции, результат не возвращается функцией напрямую. Асинхронное программирование основано на функциях обратного вызова, которые обычно передаются как аргументы.

Если необходимо выполнить какую-либо асинхронную операцию (такую как ввод/вывод), в большинстве случаев определяется функция обратного вызова, которая вызывается после завершения операции.

Когда в решение задачи вовлекается множество асинхронных операций, организация потока ФОВ может осложниться и привести к ситуации, которую иногда называют "callback soup" или "эффект бумеранга".

## Что такое эффект бумеранга?

Эффект бумеранга возникает, когда группа ФОВ выполняется по цепочке — когда одна асинхронная операция завершается, запускается следующая. Термин "бумеранг" возник из-за формы кода, имеющего множество вложенных функций. Постепенное увеличение, а затем уменьшение отступов слева делает форму кода похожей на бумеранг.

Для иллюстрации эффекта бумеранга, можно создать скрипт, который добавляет с 0 по 10 байты из файла `a.txt` в файл `b.txt`. Оба файла находятся в текущей директории.

    var fs = require('fs');
    
    function append_some_a_to_b(callback) {
        fs.open(__dirname + '/a.txt', 'r', function(err, aFd) {
            if (err) {
                return callback(err);
            }
            var buffer = new Buffer(10);
            fs.read(aFd, buffer, 0, buffer.length, 0, function(err) {
                if (err) {
                    return callback(err);
                }
                fs.close(aFd, function(err) {
                    if (err) {
                        return callback(err);
                    }
                    fs.open(__dirname + '/b.txt', 'a', function(err, bFd) {
                        if (err) {
                            return callback(err);
                        }
                        fs.fstat(bFd, function(err, bStats) {
                            if (err) {
                                return callback(err);
                            }
                            fs.write(bFd, buffer, 0, buffer.length, bStats.size,
                                function(err) {
                                if (err) {
                                    return callback(err);
                                }
                                fs.close(bFd, callback);
                            });
                        });
                    });
                });
            });
        });
    }
    
    console.log('starting...');
    
    append_some_a_to_b(function(err) {
        if (err) {
            throw err;
        }
        console.log('done');
    });

Заметьте, что функция `append_some_a_to_b`, которая реализует поток ФОВ для задачи, использует анонимные функции, что приводит к глубоко вложенному коду. Для нетренированного глаза этот код может оказаться трудным для чтения.

Если же перед выполнением основной операции в ФОВ нужно выполнить некоторые проверочные действия, подобная ситуация может привести к множеству дублирований.

#### Примечание:

Использование анонимных ФОВ имеет по крайней мере одно преимущество. Визуальное размещение ФОВ сразу после вызова асинхронной функции дает более четкое представление о действительной последовательности операций.

Несмотря на все минусы данного подхода, иногда вложенные ФОВ имеют смысл, если ими не злоупотреблять.

---

## Избегание эффекта бумеранга с помощью объявления функций

