# Контроль потока вызовов

#### Что обсуждается в этой главе?

* Что такое эффект бумеранга
* Избегание глубого вложенных функций
* Построение программы контроля асинхронного потока
* Использование `async` для контроля потока вызовов
* Использование `async` для асинхронных итераций

---

Когда Node выполняет асинхронные операции, результат не возвращается функцией напрямую. Вместо этого, асинхронное программирование основано на функциях обратного вызова, которые обычно передаются как аргументы.

When you need to leave your process and do some I/O, most of the time you need to specify a callback function that gets invoked when that operation is fi nished.

Когда в решение задачи вовлекается множество асинхронных операций, организация потока функций обратного вызова может осложниться и привести к паттерну, который иногда называют "callback soup" или "эффект бумеранга".

## Что такое эффект бумеранга?

Эффект бумеранга возникает, когда группа ФОВ выполняется по цепочке — когда одна асинхронная операция завершается, запускается следующая. Термин "бумеранг" возник из-за формы кода, имеющего множество вложенных функций. Постепенное увеличение, а затем уменьшение отступов слева делает форму кода похожей на бумеранг.

Для иллюстрации эффекта бумеранга, можно создать скрипт, который добавляет с 0 по 10 байты из файла `a.txt` в файл `b.txt`. Оба файла находятся в текущей директории.

    var fs = require('fs');
    
    function append_some_a_to_b(callback) {
        fs.open(__dirname + '/a.txt', 'r', function(err, aFd) {
            if (err) {
                return callback(err);
            }
            var buffer = new Buffer(10);
            fs.read(aFd, buffer, 0, buffer.length, 0, function(err) {
                if (err) {
                    return callback(err);
                }
                fs.close(aFd, function(err) {
                    if (err) {
                        return callback(err);
                    }
                    fs.open(__dirname + '/b.txt', 'a', function(err, bFd) {
                        if (err) {
                            return callback(err);
                        }
                        fs.fstat(bFd, function(err, bStats) {
                            if (err) {
                                return callback(err);
                            }
                            fs.write(bFd, buffer, 0, buffer.length, bStats.size,
                                function(err) {
                                if (err) {
                                    return callback(err);
                                }
                                fs.close(bFd, callback);
                            });
                        });
                    });
                });
            });
        });
    }
    
    console.log('starting...');
    
    append_some_a_to_b(function(err) {
        if (err) {
            throw err;
        }
        console.log('done');
    });

Заметьте, что функция `append_some_a_to_b`, которая реализует поток ФОВ для задачи, реализует встроенные ФОВ, что приводит к глубоко вложенному коду. Для неподготовленного глаза этот код может оказаться трудным для чтения.

Хуже всего, что если нужно условно выполнить некоторые асинхронные операции перед завершающей операцией, подобная структура кода может привести к множеству дублирований.

#### Примечание:

Объявление ФОВ встроенными имеет по крайней мере одно преимущество. Визуальное размещение ФОВ сразу после вызова асинхронной функции дает более четкое представление о действительной последовательности операций.

Также как большинство вещей в программировании, это не единственное решение — вложенные ФОВ иногда могут иметь смысл, если ими не злоупотреблять.

---

## Избегание эффекта бумеранга с помощью объявления функций

